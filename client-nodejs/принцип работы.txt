На данный момент, в системе есть 3 программы:
- сервер (Golang, sqlite) - сервер, где хранятся данные о лицах зарегистрированных пользователей. Служит для аутентификации пользователей в системе.
- rtsp-proxy (Nodejs, TS, Express) - прокси-сервер. Подключается к ip-камере по протоколу RTSP, затем ретранслирует поток в WebSockets. По умолчанию, современные браузеры не поддерживают протокол RTSP, поэтому нам и нужен этот прокси-сервер.
- клиент (Nodejs, TS, faceAPI.js, Electron) - основной клиент для взаимодействия с пользователем. Подключается к rtsp-proxy готовит нейросетевые модели для обнаружения лиц. Может работать в 2 режимах: Отправление данных на сервер или просто проверка на спуфинг. Пока программа не удостоверится в "живости" лица, данные не отправит.

## Как работает клиент

В начале необходимо найти лицо на оптической камере. Для этого используется CNN (Сверточная Нейронная Сеть). Она определяет местонахождение лица на изображении. Эта модель носит название TinyFaceDetector. Затем, на основе полученного прямоугольника с помощью второй модели (FaceLandmarks) получаем лицевые точки. Всего их 68. Если нужна только проверка на спуфинг, можно пропустить следующие этапы. Лицевые точки можно перевести в дескриптор (эмбеддинг). Это вектор из 128 чисел представляет из себя информацию, некое "описание" характеристик лица от нейросети. Этот вектор удобнее всего отправлять на сервер и сравнивать с другими лицами.
Далее, проходит проверка на спуфинг, она будет описана позже.
После удачной проверки на стороне клиента, на сервер отправляется вектор-дескриптор и имя пользователя. Сервер находит записанный вектор по имени и методом евклидового пространства находит разницу между вектором из базы данных и отправленным. Если разница векторов менее 0.6, то принято считать, что это одно и то же лицо. Почему векторы одного и того же лица не одинаковые? От конечного эмеддинга зависит множество факторов: поворот головы, помехи камеры, которые искажают расстояния точек, неточность самой нейросети. Одно и то же лицо может иметь несколько векторов дескрипторов, но при этом, математически они должны быть максимально похожи. После отправки запроса, сервер выдает ответ, который либо подтверждает подлинность лица, либо опровергает.

## Как работает защита от спуфинга

Сразу стоит сказать, что точность защиты оставляет желать лучшего. В основном, это проблема специфики ip-камеры. Ее подключения, получения тепловизионной картинки и тд.

Сама проверка основана на анализе тепловизионной карты лица. После того как мы получили координаты лица, идет перенос лицевых точек на тепловизионный слой. Первая проблема - это инпутлаг (задержка передачи данных). Задержка идет не только между камерой и пользователем, но и между слоями. Чтобы провести синхронизацию необходимо перезагрузить клиент. Это можно сделать комбинацию Ctrl-R. Следующая проблема - расстановка камер. Расстояние между объективами камер около 2,5 см. Для анализа по пикселям это очень серьезное расхождение. Проблема решается перемещением точек смещением по x и y. Показатель смещения можно настроить в программе. Также, проблема не только в расстоянии, но и в разрешении камер. Оптический слой работает в разрешении 720p (1200x720 пикселей). Тепловизионный слой работает в 240p (426x240 пикселей). Эта проблема решается через масштабирование. Необходимо ширину оптической камеры разделить на ширину тепловизионной. Этот показатель масштаба применять в дальнейших вычислениях. Также проблему частично решает перенастройка камеры, а именно оптического слоя. С 720p до 480p (640х480 пикселей). Это также частично решает проблему инпутлага.

Камера настроена, точки накладываются, можно приступить к проверке. Ранее, проверка исходила из того, что нос холоднее лба или глаз. Если глаза получались теплее носа, то считается, что перед нами человек. Это накладывает определенные проблемы, а именно то что, злоумышленник может нагреть на бумаге области с глазами и остудить область носа. Но это не единственная проблема. Тепловизионный слой не показывает реальную температуру. Мы лишь работаем с изображением тепловой карты. Она работает по системе RGB (чем теплее объект, тем он светлее. От 0 до 255). Основная проблема - устройство использует автоэкспозицию. Это означает, что, самый теплый объект является самым светлым. То есть, может так получиться, что объект нагрет до температуры чуть выше комнатной, поэтому он будет белого цвета. Из-за подобной проблемы, лицо на камере может быть неразборчивым. Это решается размещением на фоне теплого объекта. Желательно, чтобы объект был теплее проверяемого пользователя. Но даже в таком случае, точность не гарантируется. Итак, следующий шаг - это проверка корреляций на лице. Суть в том, что у телефона или изображения тепло распределяется равномерно, в прогрессии. У человека разница в точках значительна. Можно этим и воспользоваться, например узнав отношение температур некоторых точек. Из-за проблем с масштабом и смещением камер, мне не удалось получить точное расположение носа. На визуализации все правильно, но визуализация отличается от расчетов в силу специфики языков HTML и CSS. Так получилось, что предполагаемая точка носа является теплее предполагаемых глаз. Тем не менее, это можно использовать.
Для начала находим самые теплые точки на глазах. Это внутренние уголки. Находим точку, где предположительно находится кончик носа. На визуализации, они подсвечены как красные и синяя точки соответственно. Далее, так как глаза, в основном имеют разную температуру (возможно из-за специфики камеры), находим среднюю температуру ((ЛевТ + ПравТ) / 2). Далее, находим отношение температур носа к глазам (НосТ / СредГлазТ). В ходе проверок было выяснено, что в большинстве случаев это отношение у живого человека было более 1 (1.001 и выше), у телефона около 0.98 (в особо редких случаях тоже больше единицы).

Минус такой проверки заключается в неточностях самой камеры. Иногда получается так, что этот показатель у живого человека меньше единицы, а у телефона больше. Чтобы повысить точность, можно следовать следующим советам:
- быть в центре кадра, не слишком близко, не слишком далеко.
- на фоне желательно иметь теплый объект, чтобы автоэкспозиция камеры смогла настроиться на человеческое тепло.
- время от времени перезагружать приложение. Это необходимо делать, чтобы библиотека компьютерного зрения очищала кэш. Кэш от прошлых проверок может плохо влиять на текущие проверки.
- время от времени перезагружать rtsp-proxy. Канал подключений может забиться, возможен риск утечек памяти. Это плохо скажется на скорости передачи изображения, что приведет к значительному инпутлагу.

Из заметок

Плохое качество оптической камеры (480p) может быть полезным. При таком качестве все ещё можно распознать реальное лицо, а вот лицо с телефона гораздо сложнее.